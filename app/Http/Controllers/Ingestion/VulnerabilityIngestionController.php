<?php

namespace App\Http\Controllers\Ingestion;

use App\Http\Controllers\Controller;
use App\Http\Requests\Ingestion\StoreVulnerabilitySnapshotRequest;
use App\Jobs\ProcessVulnerabilityIngestionRun;
use App\Models\IngestionRun;
use App\Models\Project;
use App\Support\WebhookTokenManager;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Str;

class VulnerabilityIngestionController extends Controller
{
    public function store(
        StoreVulnerabilitySnapshotRequest $request,
        WebhookTokenManager $webhookTokenManager,
    ): JsonResponse {
        $project = Project::query()
            ->where('slug', $request->string('project_slug')->toString())
            ->firstOrFail();

        $plainTextToken = (string) Str::of($request->bearerToken() ?? '')->trim();

        if ($plainTextToken === '' || $webhookTokenManager->resolveActiveToken($project, $plainTextToken) === null) {
            return response()->json([
                'message' => 'Invalid webhook token.',
            ], 401);
        }

        $payload = $request->validated();
        $source = strtolower(trim((string) $payload['source']));
        $snapshotId = (string) $payload['snapshot_id'];
        $payloadHash = hash('sha256', json_encode($payload));

        $existingRun = IngestionRun::query()
            ->where('project_id', $project->id)
            ->where('source', $source)
            ->where('snapshot_id', $snapshotId)
            ->first();

        if ($existingRun !== null) {
            if ($existingRun->payload_hash !== $payloadHash) {
                return response()->json([
                    'message' => 'The snapshot_id has already been used with a different payload.',
                    'errors' => [
                        'snapshot_id' => ['Duplicate snapshot_id with mismatched payload.'],
                    ],
                ], 422);
            }

            return response()->json([
                'status' => 'duplicate',
                'snapshot_id' => $snapshotId,
            ], 202);
        }

        $ingestionRun = IngestionRun::query()->create([
            'project_id' => $project->id,
            'source' => $source,
            'snapshot_id' => $snapshotId,
            'payload_hash' => $payloadHash,
            'ingested_at' => $payload['ingested_at'],
            'processed_at' => null,
        ]);

        ProcessVulnerabilityIngestionRun::dispatch(
            ingestionRunId: $ingestionRun->id,
            source: $source,
            ingestedAt: (string) $payload['ingested_at'],
            vulnerabilities: $payload['vulnerabilities'],
        );

        return response()->json([
            'status' => 'accepted',
            'snapshot_id' => $snapshotId,
        ], 202);
    }
}

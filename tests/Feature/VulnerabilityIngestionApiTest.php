<?php

use App\Jobs\ProcessVulnerabilityIngestionRun;
use App\Models\IngestionRun;
use App\Models\Project;
use App\Models\User;
use App\Support\WebhookTokenManager;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\Str;

function baseIngestionPayload(string $projectSlug, string $snapshotId): array
{
    return [
        'project_slug' => $projectSlug,
        'snapshot_id' => $snapshotId,
        'source' => 'osv',
        'ingested_at' => now()->toIso8601String(),
        'vulnerabilities' => [
            [
                'osv_url' => 'https://osv.dev/TEST-INGEST-1',
                'cvss_score' => 8.2,
                'ecosystem' => 'npm',
                'package_name' => 'axios',
                'version' => '0.27.2',
                'fixed_version' => '1.6.0',
            ],
        ],
    ];
}

test('invalid ingestion payload returns actionable 422 response', function () {
    $response = $this->postJson('/api/v1/ingestion/vulnerabilities', [
        'project_slug' => '',
        'snapshot_id' => 'invalid',
        'source' => 'unknown',
        'ingested_at' => 'not-a-date',
        'vulnerabilities' => [],
    ]);

    $response->assertStatus(422);
    $response->assertJsonValidationErrors([
        'project_slug',
        'snapshot_id',
        'source',
        'ingested_at',
        'vulnerabilities',
    ]);
});

test('duplicate snapshot submissions are idempotent and do not duplicate records', function () {
    $project = Project::factory()->create(['slug' => 'scanner-core']);
    $actor = User::factory()->create();

    $tokenPayload = app(WebhookTokenManager::class)->issue($project, $actor, 'Ingestion Token');
    $plainTextToken = $tokenPayload['plain_text_token'];

    $snapshotId = (string) Str::uuid();
    $payload = baseIngestionPayload($project->slug, $snapshotId);

    $this->postJson('/api/v1/ingestion/vulnerabilities', $payload, [
        'Authorization' => 'Bearer '.$plainTextToken,
    ])->assertStatus(202)->assertJsonPath('status', 'accepted');

    expect(DB::table('project_vulnerabilities')->where('project_id', $project->id)->count())->toBe(1);
    expect(DB::table('ingestion_runs')->where('project_id', $project->id)->count())->toBe(1);

    $this->postJson('/api/v1/ingestion/vulnerabilities', $payload, [
        'Authorization' => 'Bearer '.$plainTextToken,
    ])->assertStatus(202)->assertJsonPath('status', 'duplicate');

    expect(DB::table('project_vulnerabilities')->where('project_id', $project->id)->count())->toBe(1);
    expect(DB::table('ingestion_runs')->where('project_id', $project->id)->count())->toBe(1);
});

test('reused snapshot id with changed payload is rejected', function () {
    $project = Project::factory()->create(['slug' => 'scanner-core']);
    $actor = User::factory()->create();

    $tokenPayload = app(WebhookTokenManager::class)->issue($project, $actor, 'Ingestion Token');
    $plainTextToken = $tokenPayload['plain_text_token'];

    $snapshotId = (string) Str::uuid();
    $firstPayload = baseIngestionPayload($project->slug, $snapshotId);
    $secondPayload = baseIngestionPayload($project->slug, $snapshotId);
    $secondPayload['vulnerabilities'][0]['package_name'] = 'lodash';

    $this->postJson('/api/v1/ingestion/vulnerabilities', $firstPayload, [
        'Authorization' => 'Bearer '.$plainTextToken,
    ])->assertStatus(202);

    $this->postJson('/api/v1/ingestion/vulnerabilities', $secondPayload, [
        'Authorization' => 'Bearer '.$plainTextToken,
    ])->assertStatus(422)->assertJsonValidationErrors(['snapshot_id']);
});

test('invalid webhook token is rejected immediately', function () {
    $project = Project::factory()->create(['slug' => 'scanner-core']);
    $snapshotId = (string) Str::uuid();

    $response = $this->postJson('/api/v1/ingestion/vulnerabilities', baseIngestionPayload($project->slug, $snapshotId), [
        'Authorization' => 'Bearer invalid-token',
    ]);

    $response->assertStatus(401)->assertJsonPath('message', 'Invalid webhook token.');
});

test('ingestion endpoint dispatches async normalization job', function () {
    Queue::fake();

    $project = Project::factory()->create(['slug' => 'scanner-core']);
    $actor = User::factory()->create();
    $tokenPayload = app(WebhookTokenManager::class)->issue($project, $actor, 'Ingestion Token');
    $snapshotId = (string) Str::uuid();

    $this->postJson('/api/v1/ingestion/vulnerabilities', baseIngestionPayload($project->slug, $snapshotId), [
        'Authorization' => 'Bearer '.$tokenPayload['plain_text_token'],
    ])->assertStatus(202)->assertJsonPath('status', 'accepted');

    Queue::assertPushed(ProcessVulnerabilityIngestionRun::class, 1);
});

test('normalization job trims and normalizes incoming vulnerability fields', function () {
    $project = Project::factory()->create(['slug' => 'scanner-core']);
    $run = IngestionRun::query()->create([
        'project_id' => $project->id,
        'source' => 'osv',
        'snapshot_id' => (string) Str::uuid(),
        'payload_hash' => str_repeat('a', 64),
        'ingested_at' => now(),
        'processed_at' => null,
    ]);

    $job = new ProcessVulnerabilityIngestionRun(
        ingestionRunId: $run->id,
        source: ' OSV ',
        ingestedAt: now()->toIso8601String(),
        vulnerabilities: [
            [
                'osv_url' => ' https://osv.dev/TEST-NORM ',
                'cvss_score' => 8.1,
                'ecosystem' => ' NPM ',
                'package_name' => ' axios ',
                'version' => ' 0.27.2 ',
                'fixed_version' => ' 1.6.0 ',
            ],
        ],
    );

    $job->handle();

    $row = DB::table('project_vulnerabilities')
        ->where('project_id', $project->id)
        ->first();

    expect($row)->not->toBeNull();
    expect($row->source)->toBe('osv');
    expect($row->ecosystem)->toBe('npm');
    expect($row->package_name)->toBe('axios');
    expect($row->version)->toBe('0.27.2');
    expect($row->fixed_version)->toBe('1.6.0');
    expect($run->fresh()?->processed_at)->not->toBeNull();
});

test('latest snapshot replacement is isolated by project and source', function () {
    $project = Project::factory()->create(['slug' => 'scanner-core']);
    $actor = User::factory()->create();
    $tokenPayload = app(WebhookTokenManager::class)->issue($project, $actor, 'Ingestion Token');
    $sharedSnapshotId = (string) Str::uuid();

    $firstSnapshot = baseIngestionPayload($project->slug, $sharedSnapshotId);
    $firstSnapshot['source'] = 'osv';
    $firstSnapshot['vulnerabilities'][0]['package_name'] = 'from-osv';

    $secondSnapshot = baseIngestionPayload($project->slug, $sharedSnapshotId);
    $secondSnapshot['source'] = 'ghsa';
    $secondSnapshot['vulnerabilities'][0]['package_name'] = 'from-ghsa';

    $this->postJson('/api/v1/ingestion/vulnerabilities', $firstSnapshot, [
        'Authorization' => 'Bearer '.$tokenPayload['plain_text_token'],
    ])->assertStatus(202);

    $this->postJson('/api/v1/ingestion/vulnerabilities', $secondSnapshot, [
        'Authorization' => 'Bearer '.$tokenPayload['plain_text_token'],
    ])->assertStatus(202);

    expect(DB::table('project_vulnerabilities')
        ->where('project_id', $project->id)
        ->where('source', 'osv')
        ->where('package_name', 'from-osv')
        ->exists())->toBeTrue();

    expect(DB::table('project_vulnerabilities')
        ->where('project_id', $project->id)
        ->where('source', 'ghsa')
        ->where('package_name', 'from-ghsa')
        ->exists())->toBeTrue();
});
